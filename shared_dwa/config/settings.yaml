### Shared DWA settings
node_active: true
debug: false
fixed_frame_id: "map"
base_frame_id: "base_footprint"


collision_method: "footprint" 
# Method used to check for collision. "footprint" or 
# "radius" just checks the distance to obstacles and reports collision if the distance is smaller than obst_inflation.
# "footprint" checks whether the provided footprint is in collision with known obstacles, using obst_inflation, footprint_inflation and vel_inflation. footprint is more accurate. 

obst_type: "scan"
# options: "map", "scan", "cloud" or "obstmsg" 
# "scan" can be used with either footprint or radius mode. scan is generally the fastest. 
# "map" uses the occupancyGrid published at "/move_base/local_costmap/costmap" to avoid map based obstacles. 'collision_method' is automatically changed to "radius" when using "map" method. "map" is generally the slowest. 
# "cloud" uses a 3d pointcloud, e.g. coming from rgbd image. 
# "obstmsg" uses the obstacle message description scat_msgs::EnvObjectList.

use_adaptive: false 
# use_adaptive can be used to make shared control cost function parameters adaptive to individual user. 
# if use_adaptive = true, joystick filter node should publish performance array (see readme's)

use_ref_trajectory: false # can be used to include a reference trajectory into the cost function
use_coll_margin: false # can be used to increase cost of coming too close to obstacles. 

vel_type: odom # odom or twist

# Collision parameters
footprint_inflation: 0.5 # footprint multiplication factor. 0.2 = 20% inflation
vel_inflation: 0.4 # additional inflation factor dependent on velocity. Increase if getting stuck alongside the wall. Full inflation (e.g. 20% for factor 0.2) is added when v = v_max.

obst_inflation: 0.5 # !Only used for radius collision method! make sure this is larger than than vel_safety_filter obstacle inflation
occupancy_threshold: 50 # when costmap is used for obstacle avoidance, this parameter determines when a field is considered to be an obstacle. 
obst_range: 10.0 # Obstacles farther away than this are filtered out of the calculation. Make sure that this value is higher than v_max * (time_interval * path_samples + 1/pos_update_freq) + obst_inflation
pos_update_freq: 1.0 # used to update the position of the robot in the map

# DWA parameters
# The prediction horizon and sampling time are only used to generate paths for visualization. 
prediction_horizon: 8
sampling_time: 0.4
# samples size used to determine the size of the dynamic window.
samples_v: 8
samples_w: 8


## Cost function parameters. 
# sum of constants should always be 1.

## These constants are loaded if use_adaptive is false
Kv: 0.3 # linear velocity
Kh: 0.6 # heading (angle)
Kw: 0.0 # angular velocity, not required
## Additional parameters
Kc: 0.0 # collision (average obstacle distance, increases safety. Increase if getting stuck alongside the wall.)
Ks: 0.1  # smoothness 
Kref: 0.0 # reference trajectory if available

## constants for adaptive shared control. If use_adaptive = true
# these are used as follows: Kv = Kv0 + Kvr * (1 - var_x) 
# where var_x is the variance in x direction published by joystick_filter
# base constants
Kv0: 0.15
Kh0: 0.35
Kw0: 0.0
# range constants
Kvr: 0.2
Khr: 0.2
Kwr: 0.0

