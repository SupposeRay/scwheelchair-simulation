
void Voronoi_Algorithm::processObstacles()
{
  ROS_DEBUG_STREAM("Process Obstacles");
  // Clear the containers in which the obstacles will be loaded:
  // obstacles_pts_ is a vector containing obstacles, each described by a vector of (ros) points. 
  obstacles_pts_.clear();  
  for (scat_msgs::EnvObject object : obstacles_.objects)
  {
    createObstacle(object, obstacles_.header);
  }
 
  ROS_DEBUG_STREAM("NR of Obstacles: " << obstacles_pts_.size());
}


void Voronoi_Algorithm::createObstacle(const scat_msgs::EnvObject &object, std_msgs::Header header)
{
  // Add Walls, curbs and gaps (in the floor). All are described as lines. 
  if ( object.ID == 1 || object.ID == 2 || object.ID == 3 || object.ID == 6)
  {
    if (base_utils::checkRange(object.params[0], object.params[1], obst_range_) ||
        base_utils::checkRange(object.params[3], object.params[4], obst_range_))
      {
        obstacles_pts_.push_back(createLine(object.params[0], object.params[1],
                                          object.params[3], object.params[4],
                                          header));          
      }
  }
  // Add Tables. described as polygons.
  else if (object.ID == 4 || object.ID == 5)
  {
    obstacles_pts_.push_back(createPolygon2D(object.params,
                                        header));
  }  
  // Add Humans. described as circles.
  else if (object.ID == 7 || object.ID == 8)
  {
    obstacles_pts_.push_back(createCircle(object.params[0], object.params[1], object.params[3],
                                            header));
  }          
}

std::vector<geometry_msgs::Point> Voronoi_Algorithm::createCircle(const float &x, const float &y, const float &r,
                                                       const std_msgs::Header &header)
{
  std::vector<geometry_msgs::Point> circle;
  if (header.frame_id == base_frame_id_)
  {
    circle.push_back(rosmsg::makePoint(x, y));
  }
  else
  {
    geometry_msgs::PointStamped pt_out, pt = rosmsg::makePointStamped(x, y, header);
    try
    {
      ros::Time last_time = ros::Time(0);
      tf_listener_.waitForTransform(fixed_frame_id_, base_frame_id_, last_time, ros::Duration(0.2));
      tf_listener_.transformPoint(base_frame_id_, last_time, pt, fixed_frame_id_, pt_out);
    }
    catch (tf::TransformException ex)
    {
      ROS_ERROR("%s", ex.what());
    }
    circle.push_back(pt_out.point);
  }
  return circle;
}

std::vector<geometry_msgs::Point> Voronoi_Algorithm::createLine(const float &x1, const float &y1,
                                                       const float &x2, const float &y2,
                                                       const std_msgs::Header &header)
{
  std::vector<geometry_msgs::Point> line;
  if (header.frame_id == base_frame_id_)
  {
    line.push_back(rosmsg::makePoint(x1, y1));
    line.push_back(rosmsg::makePoint(x2, y2));
  }
  else
  {
    geometry_msgs::PointStamped pt1_out, pt1 = rosmsg::makePointStamped(x1, y1, header);
    geometry_msgs::PointStamped pt2_out, pt2 = rosmsg::makePointStamped(x2, y2, header);
    try
    {
      ros::Time last_time = ros::Time(0);
      tf_listener_.waitForTransform(fixed_frame_id_, base_frame_id_, last_time, ros::Duration(0.2));
      tf_listener_.transformPoint(base_frame_id_, last_time, pt1, fixed_frame_id_, pt1_out);
      tf_listener_.transformPoint(base_frame_id_, last_time, pt2, fixed_frame_id_, pt2_out);
    }
    catch (tf::TransformException ex)
    {
      ROS_ERROR("%s", ex.what());
    }
    line.push_back(pt1_out.point);
    line.push_back(pt2_out.point);
  }
  return line;
}

std::vector<geometry_msgs::Point> Voronoi_Algorithm::createPolygon2D(const std::vector<float> &coords,
                                                            const std_msgs::Header &header)
{
  std::vector<geometry_msgs::Point> polygon;
  if (header.frame_id == base_frame_id_)
  {
    for (int i = 0; i < coords.size(); i += 3)
    {    
      polygon.push_back(rosmsg::makePoint(coords[i], coords[i+1]));
    }
  }
  else
  {
    for (int i = 0; i < coords.size(); i += 3)
    {
      geometry_msgs::PointStamped pt_out, pt = rosmsg::makePointStamped(coords[i], coords[i+1], header);
      try
      {
        ros::Time last_time = ros::Time(0);
        tf_listener_.waitForTransform(fixed_frame_id_, base_frame_id_, last_time, ros::Duration(0.2));
        tf_listener_.transformPoint(base_frame_id_, last_time, pt, fixed_frame_id_, pt_out);
      }
      catch (tf::TransformException ex)
      {
        ROS_ERROR("%s", ex.what());
      }
      polygon.push_back(pt_out.point);
    }
  }
  return polygon;
}
